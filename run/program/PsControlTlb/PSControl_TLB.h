// ************************************************************************ //
// WARNING                                                                    
// -------                                                                    
// The types declared in this file were generated from data read from a       
// Type Library. If this type library is explicitly or indirectly (via        
// another type library referring to this type library) re-imported, or the   
// 'Refresh' command of the Type Library Editor activated while editing the   
// Type Library, the contents of this file will be regenerated and all        
// manual modifications will be lost.                                         
// ************************************************************************ //

// C++ TLBWRTR : $Revision:   1.151.1.0.1.27  $
// File generated on 03.06.2007 23:03:47 from Type Library described below.

// ************************************************************************  //
// LIBID: {F3F663E7-C6C7-44CE-8AF1-335867C0C014}
// LCID: 0
// Helpfile: 
// HelpString: PSControl Library
// DepndLst: 
//   (1) v2.0 stdole, (C:\WINDOWS\system32\stdole2.tlb)
// ************************************************************************ //
#ifndef   PSControl_TLBH
#define   PSControl_TLBH

#pragma option push -b -w-inl

#include <utilcls.h>
#if !defined(__UTILCLS_H_VERSION) || (__UTILCLS_H_VERSION < 0x0600)
//
// The code generated by the TLIBIMP utility or the Import|TypeLibrary 
// and Import|ActiveX feature of C++Builder rely on specific versions of
// the header file UTILCLS.H found in the INCLUDE\VCL directory. If an 
// older version of the file is detected, you probably need an update/patch.
//
#error "This file requires a newer version of the header UTILCLS.H" \
       "You need to apply an update/patch to your copy of C++Builder"
#endif
#include <olectl.h>
#include <ocidl.h>
#if defined(USING_ATLVCL) || defined(USING_ATL)
#if !defined(__TLB_NO_EVENT_WRAPPERS)
#include <atl/atlmod.h>
#endif
#endif


// *********************************************************************//
// Forward reference of some VCL types (to avoid including STDVCL.HPP)    
// *********************************************************************//
namespace Stdvcl {class IStrings; class IStringsDisp;}
using namespace Stdvcl;
typedef TComInterface<IStrings> IStringsPtr;
typedef TComInterface<IStringsDisp> IStringsDispPtr;

namespace Pscontrol_tlb
{

// *********************************************************************//
// HelpString: PSControl Library
// Version:    1.0
// *********************************************************************//


// *********************************************************************//
// GUIDS declared in the TypeLibrary. Following prefixes are used:        
//   Type Libraries     : LIBID_xxxx                                      
//   CoClasses          : CLSID_xxxx                                      
//   DISPInterfaces     : DIID_xxxx                                       
//   Non-DISP interfaces: IID_xxxx                                        
// *********************************************************************//
extern "C" const __declspec(selectany) GUID LIBID_PSControl = {0xF3F663E7, 0xC6C7, 0x44CE,{ 0x8A, 0xF1, 0x33,0x58, 0x67, 0xC0,0xC0, 0x14} };
extern "C" const __declspec(selectany) GUID IID_IPowerSupplyRControl = {0xE128064F, 0xF46F, 0x4ED7,{ 0xB0, 0x32, 0xC3,0x1F, 0x79, 0x48,0xD6, 0x3F} };
extern "C" const __declspec(selectany) GUID DIID_IPowerSupplyControlEvents = {0x0F8E1066, 0x69BC, 0x4552,{ 0xA4, 0x08, 0x02,0x5F, 0x37, 0x40,0x21, 0xC9} };
extern "C" const __declspec(selectany) GUID CLSID_PowerSupplyControl = {0xE275E3C6, 0xFCD1, 0x436E,{ 0x93, 0x6B, 0xFB,0x0F, 0xDA, 0x2E,0x3D, 0x71} };
extern "C" const __declspec(selectany) GUID GUID_ERPowerSupplyState = {0xE2B96E31, 0xFBB7, 0x47E4,{ 0xA9, 0x3B, 0xA0,0xAC, 0x94, 0x56,0x35, 0x2D} };
extern "C" const __declspec(selectany) GUID GUID_ERPsOverloadStatus = {0xA8194BDE, 0x2058, 0x4BCB,{ 0x81, 0x08, 0x1C,0x20, 0xD2, 0x99,0x0B, 0x58} };

// *********************************************************************//
// Forward declaration of types defined in TypeLibrary                    
// *********************************************************************//
enum      ERPowerSupplyState;
enum      ERPsOverloadStatus;
interface DECLSPEC_UUID("{E128064F-F46F-4ED7-B032-C31F7948D63F}") IPowerSupplyRControl;
typedef TComInterface<IPowerSupplyRControl, &IID_IPowerSupplyRControl> IPowerSupplyRControlPtr;

interface DECLSPEC_UUID("{0F8E1066-69BC-4552-A408-025F374021C9}") IPowerSupplyControlEvents;
typedef TComInterface<IPowerSupplyControlEvents, &DIID_IPowerSupplyControlEvents> IPowerSupplyControlEventsPtr;


// *********************************************************************//
// Declaration of CoClasses defined in Type Library                       
// (NOTE: Here we map each CoClass to its Default Interface)              
//                                                                        
// The LIBID_OF_ macro(s) map a LIBID_OF_CoClassName to the GUID of this  
// TypeLibrary. It simplifies the updating of macros when CoClass name    
// change.                                                                
// *********************************************************************//
typedef IPowerSupplyRControl PowerSupplyControl;
typedef IPowerSupplyRControlPtr PowerSupplyControlPtr;

#define LIBID_OF_PowerSupplyControl (&LIBID_PSControl)

// *********************************************************************//
// Declaration of Enumerations defined in Type Library                    
// *********************************************************************//
typedef enum ERPowerSupplyState
{
  rpssUnknown = 0xFFFFFFFF, 
  rpssDisconnected = 0, 
  rpssPowerOff = 1, 
  rpssPOST = 2, 
  rpssStandBy = 3, 
  rpssNormal = 4, 
  rpssRemoteControl = 5, 
  rpssProgramming = 6, 
  rpssCriticalError = 7, 
  rpssHighTemperature = 8
} ERPowerSupplyState;

typedef enum ERPsOverloadStatus
{
  rovrNoOverload = 0, 
  rovrOverloadNow = 1, 
  rovrOverloadWas = 2
} ERPsOverloadStatus;

// *********************************************************************//
// Interface: IPowerSupplyRControl
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E128064F-F46F-4ED7-B032-C31F7948D63F}
// *********************************************************************//
interface IPowerSupplyRControl  : public IDispatch
{
public:
  // [1] Получение состояния окна программмы (скрыта/отображена)
  virtual HRESULT STDMETHODCALLTYPE get_MainFormVisible(VARIANT_BOOL* Value/*[out,retval]*/) = 0;
  // [1] Показ/скрытие окна программы
  virtual HRESULT STDMETHODCALLTYPE set_MainFormVisible(VARIANT_BOOL Value/*[in]*/) = 0;
  // [2] Получение количества панелей с источниками питания
  virtual HRESULT STDMETHODCALLTYPE GetControlledPSCount(long* pCount/*[out,retval]*/) = 0;
  // [3] Получение состояния выбранного источника питания
  virtual HRESULT STDMETHODCALLTYPE RPsGetCurrentState(long nIndex/*[in]*/, 
                                                       Pscontrol_tlb::ERPowerSupplyState* pState/*[out,retval]*/) = 0;
  // [4] Блокировка\разблокировка элеменов управления в программе
  virtual HRESULT STDMETHODCALLTYPE LockGuiControl(VARIANT_BOOL bLock/*[in]*/) = 0;
  // [5] Установка выходного напряжения (в милливольтах) 
  virtual HRESULT STDMETHODCALLTYPE RPsSetVoltage(long nIndex/*[in]*/, long nMillivolts/*[in]*/) = 0;
  // [6] Установка выходного тока (в миллиамперах)
  virtual HRESULT STDMETHODCALLTYPE RPsSetMaxCurrent(long nIndex/*[in]*/, long nMilliamps/*[in]*/) = 0;
  // [7] Вход/выход в режим дистанционного управления
  virtual HRESULT STDMETHODCALLTYPE RPsChangeRemoteControlMode(long nIndex/*[in]*/, 
                                                               VARIANT_BOOL bEnter/*[in]*/) = 0;
  // [8] Переключение ИП в режим ожидания
  virtual HRESULT STDMETHODCALLTYPE RPsGoStandByMode(long nIndex/*[in]*/) = 0;
  // [10] Получение максимального выходного напряжения для ИП (в милливольтах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetMaxSVoltage(long nIndex/*[in]*/, 
                                                      long* pMillivolts/*[out,retval]*/) = 0;
  // [11] Получение максимального выходного тока для ИП (в миллиамперах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetMaxSCurrent(long nIndex/*[in]*/, 
                                                      long* pMilliamps/*[out,retval]*/) = 0;
  // [12] Получение измеренного напряжения на выходе ИП (в милливольтах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetMsrVoltage(long nIndex/*[in]*/, 
                                                     long* pMillivolts/*[out,retval]*/) = 0;
  // [13] Получение измеренного тока на выходе ИП (в милливольтах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetMsrCurrent(long nIndex/*[in]*/, 
                                                     long* pMilliamps/*[out,retval]*/) = 0;
  // [14] Получение измеренной температуры ИП (в миллиградусах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetMsrTemperature(long nIndex/*[in]*/, 
                                                         long* pMilliGrad/*[out,retval]*/) = 0;
  // [15] Получение скорости вращения вентилятора (в процентах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetMsrFanSpeed(long nIndex/*[in]*/, 
                                                      long* pRpm/*[out,retval]*/) = 0;
  // [16] Получение режима перегрузки
  virtual HRESULT STDMETHODCALLTYPE RPsGetOverloadStatus(long nIndex/*[in]*/, 
                                                         Pscontrol_tlb::ERPsOverloadStatus* pOvrStatus/*[out,retval]*/) = 0;
  // [9] синхронизация данных панели с данными от источника питания
  virtual HRESULT STDMETHODCALLTYPE RPsUpdateDataFromDevice(long nIndex/*[in]*/) = 0;
  // [17] Получение установленного напряжения на выходе ИП (в милливольтах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetSVoltage(long nIndex/*[in]*/, 
                                                   long* pMillivolts/*[out,retval]*/) = 0;
  // [18] Получение установленного тока на выходе ИП (в миллиамперах)
  virtual HRESULT STDMETHODCALLTYPE RPsGetSMaxCurrent(long nIndex/*[in]*/, 
                                                      long* pMilliamps/*[out,retval]*/) = 0;
  virtual HRESULT STDMETHODCALLTYPE ARPsReadCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                           long nAddress/*[in]*/, 
                                                           long nNumberOfBytesToRead/*[in]*/, 
                                                           LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                           long* pnNumberOfBytesRead/*[out]*/) = 0; // [30]
  virtual HRESULT STDMETHODCALLTYPE ARPsGetAdcChannelData(long nIndex/*[in]*/, long nChannel/*[in]*/, 
                                                          long* pnValue/*[in]*/) = 0; // [19]
  // [21] Получение содержимого ячейки ПРГ 00 - 99
  virtual HRESULT STDMETHODCALLTYPE ARPsGetPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                                  long* pMillivolts/*[out]*/, 
                                                  long* pMilliamps/*[out]*/, 
                                                  VARIANT_BOOL* pbIsEmpty/*[out]*/) = 0;
  // [22] Установка содержимого ячейки ПРГ 00 - 99
  virtual HRESULT STDMETHODCALLTYPE ARPsPutPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                                  long Millivolts/*[in]*/, long Milliamps/*[in]*/, 
                                                  VARIANT_BOOL bClear/*[in]*/) = 0;
  // [23] Очистка всех ячеек ПРГ 00 - 99
  virtual HRESULT STDMETHODCALLTYPE ARPsClearAllPreset(long nIndex/*[in]*/) = 0;
  virtual HRESULT STDMETHODCALLTYPE ARPsGetCorrectionDataSize(long nIndex/*[in]*/, 
                                                              long nCfId/*[in]*/, 
                                                              long* pnSize/*[out]*/) = 0; // [24]
  virtual HRESULT STDMETHODCALLTYPE ARPsWriteCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                            long nAddress/*[in]*/, 
                                                            long nNumberOfBytesToWrite/*[in]*/, 
                                                            LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                            long* pnNumberOfBytesWritten/*[out]*/) = 0; // [25]
  virtual HRESULT STDMETHODCALLTYPE ARPsMoveCorDataFlash2Ram(long nIndex/*[in]*/, long nCfId/*[in]*/) = 0; // [26]
  virtual HRESULT STDMETHODCALLTYPE ARPsMoveCorDataRam2Flash(long nIndex/*[in]*/, long nCfId/*[in]*/) = 0; // [27]
  virtual HRESULT STDMETHODCALLTYPE ARPsStopRefreshRamCorData(long nIndex/*[in]*/, 
                                                              VARIANT_BOOL bStop/*[in]*/) = 0; // [28]
  // [20] Получение информации об ИП
  virtual HRESULT STDMETHODCALLTYPE GetPsInfo(long nIndex/*[in]*/, BSTR* CreatorId/*[in,out]*/, 
                                              BSTR* DeviceId/*[in,out]*/, 
                                              BSTR* SerialNumber/*[in,out]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  VARIANT_BOOL __fastcall get_MainFormVisible(void)
  {
    VARIANT_BOOL Value;
    OLECHECK(this->get_MainFormVisible((VARIANT_BOOL*)&Value));
    return Value;
  }

  long __fastcall GetControlledPSCount(void)
  {
    long pCount;
    OLECHECK(this->GetControlledPSCount((long*)&pCount));
    return pCount;
  }

  Pscontrol_tlb::ERPowerSupplyState __fastcall RPsGetCurrentState(long nIndex/*[in]*/)
  {
    Pscontrol_tlb::ERPowerSupplyState pState;
    OLECHECK(this->RPsGetCurrentState(nIndex, (Pscontrol_tlb::ERPowerSupplyState*)&pState));
    return pState;
  }

  long __fastcall RPsGetMaxSVoltage(long nIndex/*[in]*/)
  {
    long pMillivolts;
    OLECHECK(this->RPsGetMaxSVoltage(nIndex, (long*)&pMillivolts));
    return pMillivolts;
  }

  long __fastcall RPsGetMaxSCurrent(long nIndex/*[in]*/)
  {
    long pMilliamps;
    OLECHECK(this->RPsGetMaxSCurrent(nIndex, (long*)&pMilliamps));
    return pMilliamps;
  }

  long __fastcall RPsGetMsrVoltage(long nIndex/*[in]*/)
  {
    long pMillivolts;
    OLECHECK(this->RPsGetMsrVoltage(nIndex, (long*)&pMillivolts));
    return pMillivolts;
  }

  long __fastcall RPsGetMsrCurrent(long nIndex/*[in]*/)
  {
    long pMilliamps;
    OLECHECK(this->RPsGetMsrCurrent(nIndex, (long*)&pMilliamps));
    return pMilliamps;
  }

  long __fastcall RPsGetMsrTemperature(long nIndex/*[in]*/)
  {
    long pMilliGrad;
    OLECHECK(this->RPsGetMsrTemperature(nIndex, (long*)&pMilliGrad));
    return pMilliGrad;
  }

  long __fastcall RPsGetMsrFanSpeed(long nIndex/*[in]*/)
  {
    long pRpm;
    OLECHECK(this->RPsGetMsrFanSpeed(nIndex, (long*)&pRpm));
    return pRpm;
  }

  Pscontrol_tlb::ERPsOverloadStatus __fastcall RPsGetOverloadStatus(long nIndex/*[in]*/)
  {
    Pscontrol_tlb::ERPsOverloadStatus pOvrStatus;
    OLECHECK(this->RPsGetOverloadStatus(nIndex, (Pscontrol_tlb::ERPsOverloadStatus*)&pOvrStatus));
    return pOvrStatus;
  }

  long __fastcall RPsGetSVoltage(long nIndex/*[in]*/)
  {
    long pMillivolts;
    OLECHECK(this->RPsGetSVoltage(nIndex, (long*)&pMillivolts));
    return pMillivolts;
  }

  long __fastcall RPsGetSMaxCurrent(long nIndex/*[in]*/)
  {
    long pMilliamps;
    OLECHECK(this->RPsGetSMaxCurrent(nIndex, (long*)&pMilliamps));
    return pMilliamps;
  }


  __property   VARIANT_BOOL    MainFormVisible = {read = get_MainFormVisible, write = set_MainFormVisible};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: IPowerSupplyControlEvents
// Flags:     (4096) Dispatchable
// GUID:      {0F8E1066-69BC-4552-A408-025F374021C9}
// *********************************************************************//
interface IPowerSupplyControlEvents : public TDispWrapper<IDispatch>
{

};
#if !defined(__TLB_NO_INTERFACE_WRAPPERS)
// *********************************************************************//
// SmartIntf: TCOMIPowerSupplyRControl
// Interface: IPowerSupplyRControl
// *********************************************************************//
template <class T /* IPowerSupplyRControl */ >
class TCOMIPowerSupplyRControlT : public TComInterface<IPowerSupplyRControl>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMIPowerSupplyRControlT() {}
  TCOMIPowerSupplyRControlT(IPowerSupplyRControl *intf, bool addRef = false) : TComInterface<IPowerSupplyRControl>(intf, addRef) {}
  TCOMIPowerSupplyRControlT(const TCOMIPowerSupplyRControlT& src) : TComInterface<IPowerSupplyRControl>(src) {}
  TCOMIPowerSupplyRControlT& operator=(const TCOMIPowerSupplyRControlT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_MainFormVisible(VARIANT_BOOL* Value/*[out,retval]*/);
  HRESULT         __fastcall get_MainFormVisible(TOLEBOOL* Value/*[out,retval]*/);
  TOLEBOOL        __fastcall get_MainFormVisible(void);
  HRESULT         __fastcall set_MainFormVisible(VARIANT_BOOL Value/*[in]*/);
  HRESULT         __fastcall set_MainFormVisible(TOLEBOOL Value/*[in]*/);
  HRESULT         __fastcall GetControlledPSCount(long* pCount/*[out,retval]*/);
  long            __fastcall GetControlledPSCount(void);
  HRESULT         __fastcall RPsGetCurrentState(long nIndex/*[in]*/, 
                                                Pscontrol_tlb::ERPowerSupplyState* pState/*[out,retval]*/);
  Pscontrol_tlb::ERPowerSupplyState __fastcall RPsGetCurrentState(long nIndex/*[in]*/);
  HRESULT         __fastcall LockGuiControl(VARIANT_BOOL bLock/*[in]*/);
  HRESULT         __fastcall RPsSetVoltage(long nIndex/*[in]*/, long nMillivolts/*[in]*/);
  HRESULT         __fastcall RPsSetMaxCurrent(long nIndex/*[in]*/, long nMilliamps/*[in]*/);
  HRESULT         __fastcall RPsChangeRemoteControlMode(long nIndex/*[in]*/, 
                                                        VARIANT_BOOL bEnter/*[in]*/);
  HRESULT         __fastcall RPsGoStandByMode(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMaxSVoltage(long nIndex/*[in]*/, 
                                               long* pMillivolts/*[out,retval]*/);
  long            __fastcall RPsGetMaxSVoltage(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMaxSCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/);
  long            __fastcall RPsGetMaxSCurrent(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrVoltage(long nIndex/*[in]*/, long* pMillivolts/*[out,retval]*/);
  long            __fastcall RPsGetMsrVoltage(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/);
  long            __fastcall RPsGetMsrCurrent(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrTemperature(long nIndex/*[in]*/, 
                                                  long* pMilliGrad/*[out,retval]*/);
  long            __fastcall RPsGetMsrTemperature(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrFanSpeed(long nIndex/*[in]*/, long* pRpm/*[out,retval]*/);
  long            __fastcall RPsGetMsrFanSpeed(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetOverloadStatus(long nIndex/*[in]*/, 
                                                  Pscontrol_tlb::ERPsOverloadStatus* pOvrStatus/*[out,retval]*/);
  Pscontrol_tlb::ERPsOverloadStatus __fastcall RPsGetOverloadStatus(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsUpdateDataFromDevice(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetSVoltage(long nIndex/*[in]*/, long* pMillivolts/*[out,retval]*/);
  long            __fastcall RPsGetSVoltage(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetSMaxCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/);
  long            __fastcall RPsGetSMaxCurrent(long nIndex/*[in]*/);
  HRESULT         __fastcall ARPsReadCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                    long nAddress/*[in]*/, 
                                                    long nNumberOfBytesToRead/*[in]*/, 
                                                    LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                    long* pnNumberOfBytesRead/*[out]*/);
  HRESULT         __fastcall ARPsGetAdcChannelData(long nIndex/*[in]*/, long nChannel/*[in]*/, 
                                                   long* pnValue/*[in]*/);
  HRESULT         __fastcall ARPsGetPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                           long* pMillivolts/*[out]*/, long* pMilliamps/*[out]*/, 
                                           VARIANT_BOOL* pbIsEmpty/*[out]*/);
  HRESULT         __fastcall ARPsPutPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                           long Millivolts/*[in]*/, long Milliamps/*[in]*/, 
                                           VARIANT_BOOL bClear/*[in]*/);
  HRESULT         __fastcall ARPsClearAllPreset(long nIndex/*[in]*/);
  HRESULT         __fastcall ARPsGetCorrectionDataSize(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                       long* pnSize/*[out]*/);
  HRESULT         __fastcall ARPsWriteCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                     long nAddress/*[in]*/, 
                                                     long nNumberOfBytesToWrite/*[in]*/, 
                                                     LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                     long* pnNumberOfBytesWritten/*[out]*/);
  HRESULT         __fastcall ARPsMoveCorDataFlash2Ram(long nIndex/*[in]*/, long nCfId/*[in]*/);
  HRESULT         __fastcall ARPsMoveCorDataRam2Flash(long nIndex/*[in]*/, long nCfId/*[in]*/);
  HRESULT         __fastcall ARPsStopRefreshRamCorData(long nIndex/*[in]*/, 
                                                       VARIANT_BOOL bStop/*[in]*/);
  HRESULT         __fastcall GetPsInfo(long nIndex/*[in]*/, BSTR* CreatorId/*[in,out]*/, 
                                       BSTR* DeviceId/*[in,out]*/, BSTR* SerialNumber/*[in,out]*/);

  __property   TOLEBOOL        MainFormVisible = {read = get_MainFormVisible, write = set_MainFormVisible};
};
typedef TCOMIPowerSupplyRControlT<IPowerSupplyRControl> TCOMIPowerSupplyRControl;

// *********************************************************************//
// DispIntf:  IPowerSupplyRControl
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E128064F-F46F-4ED7-B032-C31F7948D63F}
// *********************************************************************//
template<class T>
class IPowerSupplyRControlDispT : public TAutoDriver<IPowerSupplyRControl>
{
public:
  IPowerSupplyRControlDispT(){}

  IPowerSupplyRControlDispT(IPowerSupplyRControl *pintf)
  {
    TAutoDriver<IPowerSupplyRControl>::Bind(pintf, false);
  }

  IPowerSupplyRControlDispT(IPowerSupplyRControlPtr pintf)
  {
    TAutoDriver<IPowerSupplyRControl>::Bind(pintf, true);
  }

  IPowerSupplyRControlDispT& operator=(IPowerSupplyRControl *pintf)
  {
    TAutoDriver<IPowerSupplyRControl>::Bind(pintf, false);
    return *this;
  }

  IPowerSupplyRControlDispT& operator=(IPowerSupplyRControlPtr pintf)
  {
    TAutoDriver<IPowerSupplyRControl>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_PowerSupplyControl));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_PowerSupplyControl);
  }

  HRESULT         __fastcall get_MainFormVisible(VARIANT_BOOL* Value/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_MainFormVisible(void);
  HRESULT         __fastcall set_MainFormVisible(VARIANT_BOOL Value/*[in]*/);
  HRESULT         __fastcall GetControlledPSCount(long* pCount/*[out,retval]*/);
  long            __fastcall GetControlledPSCount(void);
  HRESULT         __fastcall RPsGetCurrentState(long nIndex/*[in]*/, 
                                                Pscontrol_tlb::ERPowerSupplyState* pState/*[out,retval]*/);
  Pscontrol_tlb::ERPowerSupplyState __fastcall RPsGetCurrentState(long nIndex/*[in]*/);
  HRESULT         __fastcall LockGuiControl(VARIANT_BOOL bLock/*[in]*/);
  HRESULT         __fastcall RPsSetVoltage(long nIndex/*[in]*/, long nMillivolts/*[in]*/);
  HRESULT         __fastcall RPsSetMaxCurrent(long nIndex/*[in]*/, long nMilliamps/*[in]*/);
  HRESULT         __fastcall RPsChangeRemoteControlMode(long nIndex/*[in]*/, 
                                                        VARIANT_BOOL bEnter/*[in]*/);
  HRESULT         __fastcall RPsGoStandByMode(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMaxSVoltage(long nIndex/*[in]*/, 
                                               long* pMillivolts/*[out,retval]*/);
  long            __fastcall RPsGetMaxSVoltage(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMaxSCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/);
  long            __fastcall RPsGetMaxSCurrent(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrVoltage(long nIndex/*[in]*/, long* pMillivolts/*[out,retval]*/);
  long            __fastcall RPsGetMsrVoltage(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/);
  long            __fastcall RPsGetMsrCurrent(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrTemperature(long nIndex/*[in]*/, 
                                                  long* pMilliGrad/*[out,retval]*/);
  long            __fastcall RPsGetMsrTemperature(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetMsrFanSpeed(long nIndex/*[in]*/, long* pRpm/*[out,retval]*/);
  long            __fastcall RPsGetMsrFanSpeed(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetOverloadStatus(long nIndex/*[in]*/, 
                                                  Pscontrol_tlb::ERPsOverloadStatus* pOvrStatus/*[out,retval]*/);
  Pscontrol_tlb::ERPsOverloadStatus __fastcall RPsGetOverloadStatus(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsUpdateDataFromDevice(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetSVoltage(long nIndex/*[in]*/, long* pMillivolts/*[out,retval]*/);
  long            __fastcall RPsGetSVoltage(long nIndex/*[in]*/);
  HRESULT         __fastcall RPsGetSMaxCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/);
  long            __fastcall RPsGetSMaxCurrent(long nIndex/*[in]*/);
  HRESULT         __fastcall ARPsReadCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                    long nAddress/*[in]*/, 
                                                    long nNumberOfBytesToRead/*[in]*/, 
                                                    LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                    long* pnNumberOfBytesRead/*[out]*/);
  HRESULT         __fastcall ARPsGetAdcChannelData(long nIndex/*[in]*/, long nChannel/*[in]*/, 
                                                   long* pnValue/*[in]*/);
  HRESULT         __fastcall ARPsGetPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                           long* pMillivolts/*[out]*/, long* pMilliamps/*[out]*/, 
                                           VARIANT_BOOL* pbIsEmpty/*[out]*/);
  HRESULT         __fastcall ARPsPutPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                           long Millivolts/*[in]*/, long Milliamps/*[in]*/, 
                                           VARIANT_BOOL bClear/*[in]*/);
  HRESULT         __fastcall ARPsClearAllPreset(long nIndex/*[in]*/);
  HRESULT         __fastcall ARPsGetCorrectionDataSize(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                       long* pnSize/*[out]*/);
  HRESULT         __fastcall ARPsWriteCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                     long nAddress/*[in]*/, 
                                                     long nNumberOfBytesToWrite/*[in]*/, 
                                                     LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                     long* pnNumberOfBytesWritten/*[out]*/);
  HRESULT         __fastcall ARPsMoveCorDataFlash2Ram(long nIndex/*[in]*/, long nCfId/*[in]*/);
  HRESULT         __fastcall ARPsMoveCorDataRam2Flash(long nIndex/*[in]*/, long nCfId/*[in]*/);
  HRESULT         __fastcall ARPsStopRefreshRamCorData(long nIndex/*[in]*/, 
                                                       VARIANT_BOOL bStop/*[in]*/);
  HRESULT         __fastcall GetPsInfo(long nIndex/*[in]*/, BSTR* CreatorId/*[in,out]*/, 
                                       BSTR* DeviceId/*[in,out]*/, BSTR* SerialNumber/*[in,out]*/);

  __property   VARIANT_BOOL    MainFormVisible = {read = get_MainFormVisible, write = set_MainFormVisible};
};
typedef IPowerSupplyRControlDispT<IPowerSupplyRControl> IPowerSupplyRControlDisp;

// *********************************************************************//
// DispIntf:  IPowerSupplyControlEvents
// Flags:     (4096) Dispatchable
// GUID:      {0F8E1066-69BC-4552-A408-025F374021C9}
// *********************************************************************//
template <class T>
class IPowerSupplyControlEventsDispT : public TAutoDriver<IPowerSupplyControlEvents>
{
public:
  IPowerSupplyControlEventsDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }


};
typedef IPowerSupplyControlEventsDispT<IPowerSupplyControlEvents> IPowerSupplyControlEventsDisp;

// *********************************************************************//
// SmartIntf: TCOMIPowerSupplyRControl
// Interface: IPowerSupplyRControl
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::get_MainFormVisible(VARIANT_BOOL* Value/*[out,retval]*/)
{
  return (*this)->get_MainFormVisible(Value);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::get_MainFormVisible(TOLEBOOL* Value/*[out,retval]*/)
{
  return (*this)->get_MainFormVisible(VARIANT_BOOL*)Value);
}

template <class T> TOLEBOOL __fastcall
TCOMIPowerSupplyRControlT<T>::get_MainFormVisible(void)
{
  VARIANT_BOOL Value;
  OLECHECK(this->get_MainFormVisible((VARIANT_BOOL*)&Value));
  return (TOLEBOOL)Value;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::set_MainFormVisible(VARIANT_BOOL Value/*[in]*/)
{
  return (*this)->set_MainFormVisible(Value);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::set_MainFormVisible(TOLEBOOL Value/*[in]*/)
{
  return (*this)->set_MainFormVisible(VARIANT_BOOL)Value);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::GetControlledPSCount(long* pCount/*[out,retval]*/)
{
  return (*this)->GetControlledPSCount(pCount);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::GetControlledPSCount(void)
{
  long pCount;
  OLECHECK(this->GetControlledPSCount((long*)&pCount));
  return pCount;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetCurrentState(long nIndex/*[in]*/, 
                                                 Pscontrol_tlb::ERPowerSupplyState* pState/*[out,retval]*/)
{
  return (*this)->RPsGetCurrentState(nIndex, pState);
}

template <class T> Pscontrol_tlb::ERPowerSupplyState __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetCurrentState(long nIndex/*[in]*/)
{
  Pscontrol_tlb::ERPowerSupplyState pState;
  OLECHECK(this->RPsGetCurrentState(, (Pscontrol_tlb::ERPowerSupplyState*)&pState));
  return pState;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::LockGuiControl(VARIANT_BOOL bLock/*[in]*/)
{
  return (*this)->LockGuiControl(bLock);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsSetVoltage(long nIndex/*[in]*/, long nMillivolts/*[in]*/)
{
  return (*this)->RPsSetVoltage(nIndex, nMillivolts);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsSetMaxCurrent(long nIndex/*[in]*/, long nMilliamps/*[in]*/)
{
  return (*this)->RPsSetMaxCurrent(nIndex, nMilliamps);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsChangeRemoteControlMode(long nIndex/*[in]*/, 
                                                         VARIANT_BOOL bEnter/*[in]*/)
{
  return (*this)->RPsChangeRemoteControlMode(nIndex, bEnter);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGoStandByMode(long nIndex/*[in]*/)
{
  return (*this)->RPsGoStandByMode(nIndex);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMaxSVoltage(long nIndex/*[in]*/, 
                                                long* pMillivolts/*[out,retval]*/)
{
  return (*this)->RPsGetMaxSVoltage(nIndex, pMillivolts);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMaxSVoltage(long nIndex/*[in]*/)
{
  long pMillivolts;
  OLECHECK(this->RPsGetMaxSVoltage(, (long*)&pMillivolts));
  return pMillivolts;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMaxSCurrent(long nIndex/*[in]*/, 
                                                long* pMilliamps/*[out,retval]*/)
{
  return (*this)->RPsGetMaxSCurrent(nIndex, pMilliamps);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMaxSCurrent(long nIndex/*[in]*/)
{
  long pMilliamps;
  OLECHECK(this->RPsGetMaxSCurrent(, (long*)&pMilliamps));
  return pMilliamps;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrVoltage(long nIndex/*[in]*/, 
                                               long* pMillivolts/*[out,retval]*/)
{
  return (*this)->RPsGetMsrVoltage(nIndex, pMillivolts);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrVoltage(long nIndex/*[in]*/)
{
  long pMillivolts;
  OLECHECK(this->RPsGetMsrVoltage(, (long*)&pMillivolts));
  return pMillivolts;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/)
{
  return (*this)->RPsGetMsrCurrent(nIndex, pMilliamps);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrCurrent(long nIndex/*[in]*/)
{
  long pMilliamps;
  OLECHECK(this->RPsGetMsrCurrent(, (long*)&pMilliamps));
  return pMilliamps;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrTemperature(long nIndex/*[in]*/, 
                                                   long* pMilliGrad/*[out,retval]*/)
{
  return (*this)->RPsGetMsrTemperature(nIndex, pMilliGrad);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrTemperature(long nIndex/*[in]*/)
{
  long pMilliGrad;
  OLECHECK(this->RPsGetMsrTemperature(, (long*)&pMilliGrad));
  return pMilliGrad;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrFanSpeed(long nIndex/*[in]*/, long* pRpm/*[out,retval]*/)
{
  return (*this)->RPsGetMsrFanSpeed(nIndex, pRpm);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetMsrFanSpeed(long nIndex/*[in]*/)
{
  long pRpm;
  OLECHECK(this->RPsGetMsrFanSpeed(, (long*)&pRpm));
  return pRpm;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetOverloadStatus(long nIndex/*[in]*/, 
                                                   Pscontrol_tlb::ERPsOverloadStatus* pOvrStatus/*[out,retval]*/)
{
  return (*this)->RPsGetOverloadStatus(nIndex, pOvrStatus);
}

template <class T> Pscontrol_tlb::ERPsOverloadStatus __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetOverloadStatus(long nIndex/*[in]*/)
{
  Pscontrol_tlb::ERPsOverloadStatus pOvrStatus;
  OLECHECK(this->RPsGetOverloadStatus(, (Pscontrol_tlb::ERPsOverloadStatus*)&pOvrStatus));
  return pOvrStatus;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsUpdateDataFromDevice(long nIndex/*[in]*/)
{
  return (*this)->RPsUpdateDataFromDevice(nIndex);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetSVoltage(long nIndex/*[in]*/, long* pMillivolts/*[out,retval]*/)
{
  return (*this)->RPsGetSVoltage(nIndex, pMillivolts);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetSVoltage(long nIndex/*[in]*/)
{
  long pMillivolts;
  OLECHECK(this->RPsGetSVoltage(, (long*)&pMillivolts));
  return pMillivolts;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetSMaxCurrent(long nIndex/*[in]*/, 
                                                long* pMilliamps/*[out,retval]*/)
{
  return (*this)->RPsGetSMaxCurrent(nIndex, pMilliamps);
}

template <class T> long __fastcall
TCOMIPowerSupplyRControlT<T>::RPsGetSMaxCurrent(long nIndex/*[in]*/)
{
  long pMilliamps;
  OLECHECK(this->RPsGetSMaxCurrent(, (long*)&pMilliamps));
  return pMilliamps;
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsReadCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                     long nAddress/*[in]*/, 
                                                     long nNumberOfBytesToRead/*[in]*/, 
                                                     LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                     long* pnNumberOfBytesRead/*[out]*/)
{
  return (*this)->ARPsReadCorrectionData(nIndex, nCfId, nAddress, nNumberOfBytesToRead, ppsaBuffer, 
                                         pnNumberOfBytesRead);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsGetAdcChannelData(long nIndex/*[in]*/, long nChannel/*[in]*/, 
                                                    long* pnValue/*[in]*/)
{
  return (*this)->ARPsGetAdcChannelData(nIndex, nChannel, pnValue);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsGetPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                            long* pMillivolts/*[out]*/, long* pMilliamps/*[out]*/, 
                                            VARIANT_BOOL* pbIsEmpty/*[out]*/)
{
  return (*this)->ARPsGetPreset(nIndex, nPresetIndex, pMillivolts, pMilliamps, pbIsEmpty);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsPutPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                            long Millivolts/*[in]*/, long Milliamps/*[in]*/, 
                                            VARIANT_BOOL bClear/*[in]*/)
{
  return (*this)->ARPsPutPreset(nIndex, nPresetIndex, Millivolts, Milliamps, bClear);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsClearAllPreset(long nIndex/*[in]*/)
{
  return (*this)->ARPsClearAllPreset(nIndex);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsGetCorrectionDataSize(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                        long* pnSize/*[out]*/)
{
  return (*this)->ARPsGetCorrectionDataSize(nIndex, nCfId, pnSize);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsWriteCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                      long nAddress/*[in]*/, 
                                                      long nNumberOfBytesToWrite/*[in]*/, 
                                                      LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                      long* pnNumberOfBytesWritten/*[out]*/)
{
  return (*this)->ARPsWriteCorrectionData(nIndex, nCfId, nAddress, nNumberOfBytesToWrite, ppsaBuffer, 
                                          pnNumberOfBytesWritten);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsMoveCorDataFlash2Ram(long nIndex/*[in]*/, long nCfId/*[in]*/)
{
  return (*this)->ARPsMoveCorDataFlash2Ram(nIndex, nCfId);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsMoveCorDataRam2Flash(long nIndex/*[in]*/, long nCfId/*[in]*/)
{
  return (*this)->ARPsMoveCorDataRam2Flash(nIndex, nCfId);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::ARPsStopRefreshRamCorData(long nIndex/*[in]*/, 
                                                        VARIANT_BOOL bStop/*[in]*/)
{
  return (*this)->ARPsStopRefreshRamCorData(nIndex, bStop);
}

template <class T> HRESULT __fastcall
TCOMIPowerSupplyRControlT<T>::GetPsInfo(long nIndex/*[in]*/, BSTR* CreatorId/*[in,out]*/, 
                                        BSTR* DeviceId/*[in,out]*/, BSTR* SerialNumber/*[in,out]*/)
{
  return (*this)->GetPsInfo(nIndex, CreatorId, DeviceId, SerialNumber);
}

// *********************************************************************//
// DispIntf:  IPowerSupplyRControl
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E128064F-F46F-4ED7-B032-C31F7948D63F}
// *********************************************************************//
template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::get_MainFormVisible(VARIANT_BOOL* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("MainFormVisible"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Value /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
IPowerSupplyRControlDispT<T>::get_MainFormVisible(void)
{
  VARIANT_BOOL Value;
  this->get_MainFormVisible((VARIANT_BOOL*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::set_MainFormVisible(VARIANT_BOOL Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("MainFormVisible"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = Value /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::GetControlledPSCount(long* pCount/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetControlledPSCount"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pCount /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::GetControlledPSCount(void)
{
  long pCount;
  this->GetControlledPSCount((long*)&pCount);
  return pCount;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetCurrentState(long nIndex/*[in]*/, 
                                                 Pscontrol_tlb::ERPowerSupplyState* pState/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetCurrentState"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr((int*)pState /*[VT_USERDEFINED:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Pscontrol_tlb::ERPowerSupplyState __fastcall
IPowerSupplyRControlDispT<T>::RPsGetCurrentState(long nIndex/*[in]*/)
{
  Pscontrol_tlb::ERPowerSupplyState pState;
  this->RPsGetCurrentState(nIndex, (Pscontrol_tlb::ERPowerSupplyState*)&pState);
  return pState;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::LockGuiControl(VARIANT_BOOL bLock/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("LockGuiControl"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = bLock /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsSetVoltage(long nIndex/*[in]*/, long nMillivolts/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsSetVoltage"), DISPID(5));
  TAutoArgs<2> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nMillivolts /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsSetMaxCurrent(long nIndex/*[in]*/, long nMilliamps/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsSetMaxCurrent"), DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nMilliamps /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsChangeRemoteControlMode(long nIndex/*[in]*/, 
                                                         VARIANT_BOOL bEnter/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsChangeRemoteControlMode"), DISPID(7));
  TAutoArgs<2> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = bEnter /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGoStandByMode(long nIndex/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGoStandByMode"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMaxSVoltage(long nIndex/*[in]*/, 
                                                long* pMillivolts/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetMaxSVoltage"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMillivolts /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMaxSVoltage(long nIndex/*[in]*/)
{
  long pMillivolts;
  this->RPsGetMaxSVoltage(nIndex, (long*)&pMillivolts);
  return pMillivolts;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMaxSCurrent(long nIndex/*[in]*/, 
                                                long* pMilliamps/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetMaxSCurrent"), DISPID(11));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMilliamps /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMaxSCurrent(long nIndex/*[in]*/)
{
  long pMilliamps;
  this->RPsGetMaxSCurrent(nIndex, (long*)&pMilliamps);
  return pMilliamps;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrVoltage(long nIndex/*[in]*/, 
                                               long* pMillivolts/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetMsrVoltage"), DISPID(12));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMillivolts /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrVoltage(long nIndex/*[in]*/)
{
  long pMillivolts;
  this->RPsGetMsrVoltage(nIndex, (long*)&pMillivolts);
  return pMillivolts;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrCurrent(long nIndex/*[in]*/, long* pMilliamps/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetMsrCurrent"), DISPID(13));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMilliamps /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrCurrent(long nIndex/*[in]*/)
{
  long pMilliamps;
  this->RPsGetMsrCurrent(nIndex, (long*)&pMilliamps);
  return pMilliamps;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrTemperature(long nIndex/*[in]*/, 
                                                   long* pMilliGrad/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetMsrTemperature"), DISPID(14));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMilliGrad /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrTemperature(long nIndex/*[in]*/)
{
  long pMilliGrad;
  this->RPsGetMsrTemperature(nIndex, (long*)&pMilliGrad);
  return pMilliGrad;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrFanSpeed(long nIndex/*[in]*/, long* pRpm/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetMsrFanSpeed"), DISPID(15));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pRpm /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetMsrFanSpeed(long nIndex/*[in]*/)
{
  long pRpm;
  this->RPsGetMsrFanSpeed(nIndex, (long*)&pRpm);
  return pRpm;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetOverloadStatus(long nIndex/*[in]*/, 
                                                   Pscontrol_tlb::ERPsOverloadStatus* pOvrStatus/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetOverloadStatus"), DISPID(16));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr((int*)pOvrStatus /*[VT_USERDEFINED:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Pscontrol_tlb::ERPsOverloadStatus __fastcall
IPowerSupplyRControlDispT<T>::RPsGetOverloadStatus(long nIndex/*[in]*/)
{
  Pscontrol_tlb::ERPsOverloadStatus pOvrStatus;
  this->RPsGetOverloadStatus(nIndex, (Pscontrol_tlb::ERPsOverloadStatus*)&pOvrStatus);
  return pOvrStatus;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsUpdateDataFromDevice(long nIndex/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsUpdateDataFromDevice"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetSVoltage(long nIndex/*[in]*/, long* pMillivolts/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetSVoltage"), DISPID(17));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMillivolts /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetSVoltage(long nIndex/*[in]*/)
{
  long pMillivolts;
  this->RPsGetSVoltage(nIndex, (long*)&pMillivolts);
  return pMillivolts;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::RPsGetSMaxCurrent(long nIndex/*[in]*/, 
                                                long* pMilliamps/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RPsGetSMaxCurrent"), DISPID(18));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OutRetValSetterPtr(pMilliamps /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
IPowerSupplyRControlDispT<T>::RPsGetSMaxCurrent(long nIndex/*[in]*/)
{
  long pMilliamps;
  this->RPsGetSMaxCurrent(nIndex, (long*)&pMilliamps);
  return pMilliamps;
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsReadCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                     long nAddress/*[in]*/, 
                                                     long nNumberOfBytesToRead/*[in]*/, 
                                                     LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                     long* pnNumberOfBytesRead/*[out]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsReadCorrectionData"), DISPID(30));
  TAutoArgs<6> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nCfId /*[VT_I4:0]*/;
  _args[3] = nAddress /*[VT_I4:0]*/;
  _args[4] = nNumberOfBytesToRead /*[VT_I4:0]*/;
  _args[5] = ppsaBuffer /*[VT_SAFEARRAY:1]*/;
  _args[6] = pnNumberOfBytesRead /*[VT_I4:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsGetAdcChannelData(long nIndex/*[in]*/, long nChannel/*[in]*/, 
                                                    long* pnValue/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsGetAdcChannelData"), DISPID(19));
  TAutoArgs<3> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nChannel /*[VT_I4:0]*/;
  _args[3] = pnValue /*[VT_I4:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsGetPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                            long* pMillivolts/*[out]*/, long* pMilliamps/*[out]*/, 
                                            VARIANT_BOOL* pbIsEmpty/*[out]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsGetPreset"), DISPID(21));
  TAutoArgs<5> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nPresetIndex /*[VT_I4:0]*/;
  _args[3] = pMillivolts /*[VT_I4:1]*/;
  _args[4] = pMilliamps /*[VT_I4:1]*/;
  _args[5] = pbIsEmpty /*[VT_BOOL:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsPutPreset(long nIndex/*[in]*/, long nPresetIndex/*[in]*/, 
                                            long Millivolts/*[in]*/, long Milliamps/*[in]*/, 
                                            VARIANT_BOOL bClear/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsPutPreset"), DISPID(22));
  TAutoArgs<5> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nPresetIndex /*[VT_I4:0]*/;
  _args[3] = Millivolts /*[VT_I4:0]*/;
  _args[4] = Milliamps /*[VT_I4:0]*/;
  _args[5] = bClear /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsClearAllPreset(long nIndex/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsClearAllPreset"), DISPID(23));
  TAutoArgs<1> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsGetCorrectionDataSize(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                        long* pnSize/*[out]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsGetCorrectionDataSize"), DISPID(24));
  TAutoArgs<3> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nCfId /*[VT_I4:0]*/;
  _args[3] = pnSize /*[VT_I4:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsWriteCorrectionData(long nIndex/*[in]*/, long nCfId/*[in]*/, 
                                                      long nAddress/*[in]*/, 
                                                      long nNumberOfBytesToWrite/*[in]*/, 
                                                      LPSAFEARRAY* ppsaBuffer/*[in,out]*/, 
                                                      long* pnNumberOfBytesWritten/*[out]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsWriteCorrectionData"), DISPID(25));
  TAutoArgs<6> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nCfId /*[VT_I4:0]*/;
  _args[3] = nAddress /*[VT_I4:0]*/;
  _args[4] = nNumberOfBytesToWrite /*[VT_I4:0]*/;
  _args[5] = ppsaBuffer /*[VT_SAFEARRAY:1]*/;
  _args[6] = pnNumberOfBytesWritten /*[VT_I4:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsMoveCorDataFlash2Ram(long nIndex/*[in]*/, long nCfId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsMoveCorDataFlash2Ram"), DISPID(26));
  TAutoArgs<2> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nCfId /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsMoveCorDataRam2Flash(long nIndex/*[in]*/, long nCfId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsMoveCorDataRam2Flash"), DISPID(27));
  TAutoArgs<2> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = nCfId /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::ARPsStopRefreshRamCorData(long nIndex/*[in]*/, 
                                                        VARIANT_BOOL bStop/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ARPsStopRefreshRamCorData"), DISPID(28));
  TAutoArgs<2> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = bStop /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
IPowerSupplyRControlDispT<T>::GetPsInfo(long nIndex/*[in]*/, BSTR* CreatorId/*[in,out]*/, 
                                        BSTR* DeviceId/*[in,out]*/, BSTR* SerialNumber/*[in,out]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetPsInfo"), DISPID(20));
  TAutoArgs<4> _args;
  _args[1] = nIndex /*[VT_I4:0]*/;
  _args[2] = CreatorId /*[VT_BSTR:1]*/;
  _args[3] = DeviceId /*[VT_BSTR:1]*/;
  _args[4] = SerialNumber /*[VT_BSTR:1]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  IPowerSupplyControlEvents
// Flags:     (4096) Dispatchable
// GUID:      {0F8E1066-69BC-4552-A408-025F374021C9}
// *********************************************************************//
// *********************************************************************//
// The following typedefs expose classes (named CoCoClassName) that       
// provide static Create() and CreateRemote(LPWSTR machineName) methods   
// for creating an instance of an exposed object. These functions can     
// be used by client wishing to automate CoClasses exposed by this        
// typelibrary.                                                           
// *********************************************************************//

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : PowerSupplyControl
// Interface: TCOMIPowerSupplyRControl
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIPowerSupplyRControl, IPowerSupplyRControl, &CLSID_PowerSupplyControl, &IID_IPowerSupplyRControl> CoPowerSupplyControl;
#endif  //   __TLB_NO_INTERFACE_WRAPPERS


#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_ATLVCL)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : PowerSupplyControl
// Event Interface : IPowerSupplyControlEvents
// *********************************************************************//
template <class T>
class TEvents_PowerSupplyControl : public IConnectionPointImpl<T,
                                                 &DIID_IPowerSupplyControlEvents,
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
 /* Note: if encountering problems with events, please change CComUnkArray to CComDynamicUnkArray in the line above. */
{
public:
protected:
  IPowerSupplyControlEventsDisp m_EventIntfObj;
};

#endif  //   __TLB_NO_EVENT_WRAPPERS

};     // namespace Pscontrol_tlb

#if !defined(NO_IMPLICIT_NAMESPACE_USE)
using  namespace Pscontrol_tlb;
#endif

#pragma option pop

#endif // PSControl_TLBH
